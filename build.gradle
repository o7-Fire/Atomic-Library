import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
        maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
        maven { url "https://oss.sonatype.org/content/repositories/releases/" }
        maven { url 'https://jitpack.io' }
        google()

        maven {
            url "https://plugins.gradle.org/m2/"
        }
        dependencies {

            classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:3.3"
        }
    }
}

apply plugin: "org.sonarqube"
sonarqube {
    properties {
        property "sonar.projectKey", "o7-Fire_Atomic-Library"
        property "sonar.organization", "o7-ire"
    }
}
allprojects {


    repositories {
        mavenLocal()
        mavenCentral()
        google()
        maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
        maven { url "https://oss.sonatype.org/content/repositories/releases/" }
        maven { url 'https://jitpack.io' }
    }
    try {
        buildScan {
            termsOfServiceUrl = 'https://gradle.com/terms-of-service'
            termsOfServiceAgree = 'yes'
        }
    } catch (e){

    }
}


subprojects {
    apply plugin: 'java'
    apply plugin: 'java-library'
    apply plugin: "org.sonarqube"
    apply plugin: 'jacoco'
    apply plugin: 'maven-publish'

    group 'org.o7.Fire'
    version '5.0'
    sonarqube {
        properties {
            property "sonar.projectKey", "o7-Fire_Atomic-Library"
            property "sonar.organization", "o7-ire"
        }
    }

    jacocoTestReport {
        reports {
            xml.enabled true
        }
    }
    test {
        useJUnitPlatform()
        finalizedBy(jacocoTestReport)
        testLogging {
            // set options for log level LIFECYCLE
            events TestLogEvent.FAILED,
                    TestLogEvent.PASSED,
                    TestLogEvent.SKIPPED,
                    TestLogEvent.STANDARD_OUT
            exceptionFormat TestExceptionFormat.FULL
            showExceptions true
            showCauses true
            showStackTraces true
            ignoreFailures false
            setWorkingDir(rootProject.projectDir)
            // set options for log level DEBUG and INFO
            debug {
                events TestLogEvent.STARTED,
                        TestLogEvent.FAILED,
                        TestLogEvent.PASSED,
                        TestLogEvent.SKIPPED,
                        TestLogEvent.STANDARD_ERROR,
                        TestLogEvent.STANDARD_OUT
                exceptionFormat TestExceptionFormat.FULL
            }
            info.events = debug.events
            info.exceptionFormat = debug.exceptionFormat
            maxParallelForks = Runtime.getRuntime().availableProcessors()
            //forkEvery = 1
            beforeTest { descriptor ->
                logger.lifecycle("Running test: " + descriptor)
            }
            afterSuite { desc, result ->
                if (!desc.parent) { // will match the outermost suite
                    def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} passed, ${result.failedTestCount} failed, ${result.skippedTestCount} skipped)"
                    def startItem = '|  ', endItem = '  |'
                    def repeatLength = startItem.length() + output.length() + endItem.length()
                    println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
                }
            }
        }
    }
    dependencies {
        compileOnly( group: 'org.jetbrains', name: 'annotations', version: '22.0.0')
        testImplementation 'org.junit.jupiter:junit-jupiter-api:5.7.2'
        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.7.2'
    }
    ext {
        smh = {
        }
    }
    ext.aproj = { String module ->
        if (findProject(module) != null) {
            return project(module)
        } else {
            return project(":Atom" + module)
        }
    }

    compileJava {
        options.fork = true
        options.incremental = true
    }

    task pre {
        smh()
    }

    task sourcesJar(type: Jar, dependsOn: classes) {
        classifier = 'sources'
        from sourceSets.main.allSource
    }
    artifacts {
        archives sourcesJar
        archives jar
    }
    sourceSets {

        test {
            java {
                srcDirs = ['test']
            }
        }

    }
    tasks.withType(JavaCompile) {
        new File(projectDir, "resources/").mkdirs()
        new File(projectDir, "src/").mkdirs()
        sourceSets.main.resources.srcDirs = ["resources/"]
        sourceSets.main.java.srcDirs = ["src/"]

        options.encoding = "UTF-8"

    }

}
configure([":Atomic", ":Desktop"].collect{project(it)}){
    java{
        withJavadocJar()
        withSourcesJar()
    }

    publishing{
        publications{
            maven(MavenPublication){
                from components.java
            }
        }
    }
}
task resolveDependencies{
    doLast{
        rootProject.allprojects{ project ->
            Set<Configuration> configurations = project.buildscript.configurations + project.configurations
            configurations.findAll{c -> c.canBeResolved}.forEach{c -> c.resolve()}
        }
    }
}